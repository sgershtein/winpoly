//----------------------------------------------------------------------------
//  Project Winpoly
//
//  Copyright © 1998. All Rights Reserved.
//
//  SUBSYSTEM:    Winpoly Application
//  FILE:         tfield.cpp
//  AUTHOR:       Sergey Gershtein
//
//  OVERVIEW
//  ~~~~~~~~
//  Source file for implementation of TField class.
//
//----------------------------------------------------------------------------

#include <fstream.h>
#include <cstring.h>
#include <math.h>
#include "tarray.h"
#include "tfield.h"
#include "tpoly.h"
#include "texcept.h"
#ifndef __DLL__
   #include "brdata.h"
#endif

// избавляемся от самопересечений путем вызова функции checkselfcross()
#ifndef CHECKSELFCROSS
   #define CHECKSELFCROSS 0
#endif

// проверяем на самопересечения и останавливаем вычисления при их обнаружении
// Значения можно суммировать
// 1 - проверяем после деформации контуров
// 2 - проверяем исходное сечение перед началом вычислений
// 4 - проверяем после каждой операции объединения
// 8 - проверяем после каждой операции пересечения
// 16 - проверяем итоговое сечение
// 32 - проверяем перед просеиванием
// 64 - проверяем после просеивания
#ifndef SELFCROSSCONTROL
//   #define SELFCROSSCONTROL (1+2+4+8+16+32+64)
   #define SELFCROSSCONTROL (1+4+8+16+64)
//   #define SELFCROSSCONTROL 0
#endif

// записывать промежуточные результаты в файлы
// указывается каталог, куда писать
//#define SAVEDEBUGDIR "C:\\TEMP\\WPDEBUG"

// объединяем различные многоугольники поля между собой на тот случай,
// если они вдруг стали пересекаться
#ifndef CHECKPOLYCROSS
   #define CHECKPOLYCROSS 0
#endif

#if CHECKPOLYCROSS==0 && CHECKPOLYCROSS!=0
   #error CHECKPOLYCROSS невозможен без CHECKSELFCROSS
#endif

#if CHECKSELFCROSS!=0 && SELFCROSSCONTROL!=0
   #error Параметры CHECKSELFCROSS и SELFCROSSCONTROL не совместимы
#endif

// пытаемся нормализовываться путем объединения вновь построенного сечения
// с самим собой
#ifndef SELF_UNITE_2_NORMALIZE
   #define SELF_UNITE_2_NORMALIZE 0
#endif

#ifdef SAVEDEBUGDIR
   #include "dir.h"
#endif

// посчитать координаты минимального прямоугольника, содержащего всё поле
void TField::calcminmax(bool force) {
	if( !force && minmaxfound )
   	return;
   minmaxfound = true;
   if( !poly.length() ) {
		xmin = xmax = ymin = ymax = 0;
      return;
   }
   xmin = poly[0]->minx();
   xmax = poly[0]->maxx();
   ymin = poly[0]->miny();
   ymax = poly[0]->maxy();
   for( unsigned i = 1; i < poly.length(); i++ ) {
   	if( poly[i]->maxx() > xmax ) xmax = poly[i]->maxx();
   	if( poly[i]->maxy() > ymax ) ymax = poly[i]->maxy();
   	if( poly[i]->minx() < xmin ) xmin = poly[i]->minx();
   	if( poly[i]->miny() < ymin ) ymin = poly[i]->miny();
   }
}

// сконструировать из списка многоугольников
// список не разрушается
TField::TField(TList<TWinPoly*> pl) : minmaxfound(false), mDC(NULL),
   mBitmap(NULL),	drawThread(NULL), clientDC(NULL) {
   for( TListPtr<TWinPoly*> p = pl.head(); p; p++ )
      poly.push(*p);
}

// сконструировать по другому полю (copy constructor)
TField::TField(TField &other) : mDC(NULL),
   mBitmap(NULL),	drawThread(NULL), clientDC(NULL) {
   for( unsigned long w=0; w<other.poly.length(); w++ )
      poly.push(new TWinPoly(other.poly[w]));
   // сохраним максимумы и минимумы (если они уже известны)
   xmin = other.xmin;
   xmax = other.xmax;
   ymin = other.ymin;
   ymax = other.ymax;
   minmaxfound = other.minmaxfound;
}

/*TField& TField::operator=(TField other) {
   mDC = other.mDC;
   mBitmap = other.mBitmap;
   drawThread = other.drawThread;
   clientDC = other.clientDC;
   poly.setlength( other.poly.length() );
   for( unsigned long w=0; w<other.poly.length(); w++ )
      poly[w]=other.poly[w];
   // сохраним максимумы и минимумы (если они уже известны)
   xmin = other.xmin;
   xmax = other.xmax;
   ymin = other.ymin;
   ymax = other.ymax;
   minmaxfound = other.minmaxfound;
   return *this;
}*/


TField::~TField() {
	if( drawThread ) {
   	if( drawThread->GetStatus() == TThread::Running )
      	drawThread->TerminateAndWait();
   	delete drawThread;
   }
   if( mDC )
   	delete mDC;
   if( mBitmap )
   	delete mBitmap;
	clearAll();
}

void TField::clearAll() { // удалить все многоугольники
	for(unsigned i=0; i<poly.length(); i++)
   	if( poly[i] )
      	delete poly[i];
   poly.setlength(0);
   minmaxfound = 0;
}

#ifndef __DLL__

// сохранить поле в файле на диске
void TField::fileSave(const char *fname ) {
   ofstream fo(fname);
   if( !fo ) {
   	static char buf[100];
      sprintf(buf,"Не могу открыть файл '%s' для записи",fname);
   	Throw(buf);
   }
   fo <<
      "#\n"
      "# This file defines a set of " << poly.length() << " polygons\n"
      "# with each of them possibly having a number of holes\n"
      "# The file was generated by winpoly.exe program as a copy of\n"
      "# current field state\n"
      "#\n\n";

   // печатаем многоугольники
   fo.precision(15);
   for( unsigned long n=0; n<poly.length(); n++ ) {
      fo << "{\n";
      // вершины собственно многоугольника
      for( unsigned long i=0; i<poly[n]->nVertex(); i++ ) {
         CPoint *v = poly[n]->getVertex(i);
         fo << "\t" << (EQU(v->x,0)?0:v->x) << ' ' <<
            (EQU(v->y,0)?0:v->y) << "\n";
      }
      // выводим дырки
      for( unsigned long k=0; k<poly[n]->nHoles(); k++ ) {
         TPolygon *hole = poly[n]->getHole(k);
         fo << "\t(\n";
         for( unsigned long i=0; i<hole->nVertex(); i++ ) {
            CPoint *v = hole->getVertex(i);
            fo << "\t\t" << (EQU(v->x,0)?0:v->x) << ' ' <<
               (EQU(v->y,0)?0:v->y) << "\n";
         }
         fo << "\t)\n";
      }

      fo << "}\n";
   }
   fo.close();
}

// прочитать поле из файла на диске
void TField::fileOpen(const char *fname) {
	ifstream fi(fname);
   if( !fi ) {
   	static char buf[100];
      sprintf(buf,"Не могу открыть файл '%s'",fname);
   	Throw(buf);
   }
   clearAll();
	try {
      string token;
      token.set_paranoid_check();
      token.skip_whitespace(0);

      enum { S_OUT, S_POLY, S_HOLE } status = S_OUT;

      TWinPoly *curpoly = NULL;
      TPolygon *curhole = NULL;

      while( !fi.eof() ) { // читаем из файла
         token.read_token(fi);
         if( token.is_null() )
            break;
         else if( token.compare("#",0,1)==0 ) 	// комментарий
            token.read_line(fi); 					// пропускаем до конца строки
         else if( token.compare("{") == 0 ) { 	// начало многоугольника
            if( status != S_OUT ) { 				// ошибка
               Throw("Ошибка во входном файле - неожиданная '{'");
            }
            status = S_POLY;
				curpoly = poly[poly.length()] = new TWinPoly();
         } else if( token.compare("}") == 0 ) {	// конец многоугольника
            if( status != S_POLY ) { 				// ошибка
               Throw("Ошибка во входном файле - неожиданная '}'");
            }
            status = S_OUT;
            curpoly = NULL;
         } else if( token.compare("(") == 0 ) {	// начало дырки
            if( status != S_POLY ) { 				// ошибка
               Throw("Ошибка во входном файле - неожиданная '('");
            }
            status = S_HOLE;
            curpoly->addHole(new TPolygon);
            curhole=curpoly->getHole(curpoly->nHoles()-1);
         } else if( token.compare(")") == 0 ) {	// конец дырки
            if( status != S_HOLE ) { 				// ошибка
               Throw("Ошибка во входном файле - неожиданная ')'");
            }
            status = S_POLY;
				curhole = NULL;
         } else { // должны идти координаты точки
            if( status != S_HOLE && status != S_POLY ) { // ошибка
               Throw("Ошибка во входном файле - не хватает '{'");
            }
				long double x = _atold(token.c_str());
	         token.read_token(fi);
            if( token.is_null() )
            	break;
            long double y = _atold(token.c_str());
            if( status == S_HOLE )
            	*curhole += CPoint(x,y);
            else
            	*curpoly += CPoint(x,y);
         }
      }
      if( status != S_OUT ) {
			Throw("Неожиданный конец файла");
      }

   } catch( Exception &Ex ) { // закрыть файл и бросить исключение дальше
		fi.close();
      throw Ex;
   }
   fi.close();
}

#endif // __DLL__

// Найти на поле точку, ближайщую к заданной
CPoint TField::findClosest(CPoint &p) {
   CPoint cp = poly[0]->findClosest(p);
   for( unsigned i=1; i<poly.length(); i++ ) {
      CPoint ccp = poly[i]->findClosest(p);
      if( (ccp-p).length() < (cp-p).length() )
         cp = ccp;
   }
   return cp;
}

// Пересечь два поля.  Возвращает список многоугольников,
// образующих пересечение
TList<TWinPoly*> TField::intersect(TField *f, bool volatile *ShouldTerminate) {
   // строим список многоугольников из f
   TList<TWinPoly*> flist;
   for( unsigned j=0; j<f->poly.length(); j++ )
      flist += f->poly[j];

   // результирующий список
   TList<TWinPoly*> result;

   // цикл по всем нашим многоугольникам
   for( unsigned i=0; i<poly.length(); i++ ) {

      // цикл по всем их многоугольникам
      for( TListPtr<TWinPoly*> fp = flist.head(); fp; fp++ ) {

         // пересекаем i-того нашего с каждым из них
         TList<TWinPoly*> int2 = poly[i]->intersect(*fp, ShouldTerminate);

         if( ShouldTerminate && *ShouldTerminate ) {
            flist.clear();
            result.clear();
            int2.clear();
            return result;
         }

         // дописываем в список (на самом деле - объединяем наборы,
         // но т.к. исходнные мн-ки не пересекались, то и после
         // их пересечения с другим мн-ком они стали лишь меньше =>
         // снова не пересекаются => объединяем просто приписывая
         // в общий список)
         result += int2;

      }

   }

   // возвращаем результат
   return result;
}

// Объединить два поля.  Возвращает список многоугольников,
// образующих пересечение
TList<TWinPoly*> TField::unite(TField *f, bool volatile *ShouldTerminate) {
   // строим список многоугольников из f
   TList<TWinPoly*> flist;
   for( unsigned j=0; j<f->poly.length(); j++ )
      flist += new TWinPoly(f->poly[j]); // список копий

   // результирующий список
   TList<TWinPoly*> result;

   // цикл по всем нашим многоугольникам
   for( unsigned i=0; i<poly.length(); i++ ) {

      TWinPoly *cur = new TWinPoly(poly[i]); // делаем копию!

      // цикл по всем их многоугольникам
      while( !flist.empty() ) {
         TWinPoly *fp = flist.pop();

         // объединяем i-того нашего с каждым из них
         TList<TWinPoly*> u2 = cur->unite(fp, ShouldTerminate);

         if( ShouldTerminate && *ShouldTerminate ) {
            delete cur;
            result.clear();
            flist.clear();
            return result;
         }

         // Результатом объединения может быть:
         // а) два исходных многоугольника (если они не пересекаются)
         // б) один объединенный многоугольник (если пересекаются)
         // В первом случае в результат следует добавить только *fp,
         // во втором - ничего в результат не добавляем, за текущий
         // многоугольник берем результат объединения
         if( u2.empty() )
            Throw("Результат объединения двух непустых многоугольников пуст!");
         if( u2.head() == u2.tail() ) {
            // результат - один многоугольник
            delete cur;
            cur = u2.pop();
            delete fp;
         } else {
            // результат - два исходных многоугольника
            // cur сохраняем, а fp приписываем в результирующий список
            result += fp;
         }

      }
      // Оставшийся многоугольник дописываем в результирующий список
      result += cur;
      flist = result;
      result.clear();
   }

   // возвращаем результат
   return flist;
}

#ifndef __DLL__

// найти предыдущее (t-delta) сечение моста, если *this - это текущее
// (попятная процедура)
// Параметры задаются классом TBrData
// В качестве аргумента указывается текущий момент времени
TField* TField::Wprev(long double t, bool volatile *ShouldTerminate) {
   TBrData brdata;   // класс, описывающий попятную функцию
                     // и значения параметров

#ifdef SAVEDEBUGDIR

   #define SAVEDEBUG(F,S) \
      sprintf(debugfile,"%s\\%03u-%s.wpl",debugdir,debugstep++,(S)); \
      F->fileSave(debugfile);

   char debugdir[100];
   char debugfile[100];
   unsigned debugstep=0;
   sprintf(debugdir,"%s\\%05.2Lf.dbg",SAVEDEBUGDIR,t);
   mkdir(debugdir);

   SAVEDEBUG(this,"start");

#else
   #define SAVEDEBUG(F,S)  /* none */
#endif

#if SELFCROSSCONTROL & 2
   if( this->selfcrosscontrol(ShouldTerminate) )
      Throw("Найдено самопересечение контура в исходном сечении");
#endif

   TField *Wprev = NULL;

   for( long q=0; q<=brdata.Q.last(); q++ ) {

      TField *Wunion = NULL;

      for( long p=0; p<=brdata.P.last(); p++ ) {

         TField *W = new TField;   // предыдущее сечение при данных q и p

         for( long i=0; i<=poly.last(); i++ ) { // многоугольники
            TWinPoly *wp = new TWinPoly();
            // цикл по всем вершинам
            for( unsigned long k=0; k<poly[i]->nVertex(); k++ ) {
               CPoint nv = brdata.prev(
                  *(poly[i]->getVertex(k)),
                  brdata.P[p], brdata.Q[q], t, brdata.delta );
               *wp += nv;
               if( ShouldTerminate && *ShouldTerminate ) {
                  delete W;
                  delete wp;
                  return NULL;
               }
            }
            // внешний контур построен, теперь цикл по всем дыркам
            for( unsigned long h=0; h<(*(poly[i])).nHoles(); h++ ) {
               TPolygon *hole = new TPolygon();
               TPolygon *ch = (*poly[i]).getHole(h);
               // цикл по всем вершинам дырки
               for( unsigned long k=0; k<ch->nVertex(); k++ ) {
                  CPoint nv = brdata.prev(
                     *(ch->getVertex(k)),
                     brdata.P[p], brdata.Q[q], t, brdata.delta );
                  *hole += nv;
                  if( ShouldTerminate && *ShouldTerminate ) {
                     delete W;
                     delete wp;
                     delete hole;
                     return NULL;
                  }
               }
               wp->addHole(hole);
            }
            *W += wp;
         }

SAVEDEBUG(W,"deformation");

#if SELFCROSSCONTROL & 1
   if( W->selfcrosscontrol(ShouldTerminate) )
      Throw("Найдено самопересечение контура после деформации");
#endif

#if CHECKSELFCROSS==1
         // пытаемся избавиться от возможных самоперечений в контурах
         W->checkselfcross(ShouldTerminate);
#endif

#if SELF_UNITE_2_NORMALIZE==1
         // объединим полученное предыдущее сечение само с собой для
         // его нормализации (при его построении могли возникнуть
         // самопересечения, выходы дырок за границы и другие мерзости)
         TField *W1 = new TField(*W);
         TList<TWinPoly*> lself = W->unite(W1, ShouldTerminate);
         delete W; delete W1;
         W = new TField(lself);
         lself.clear();
#endif

         // Строим объединение всех W по u из P
         if( !Wunion ) { // первое сечение
            Wunion = W;
         } else { // не первое - объединяем с предыдущими
            TList<TWinPoly*> uns = Wunion->unite(W, ShouldTerminate);
            TField *un = new TField(uns);
            uns.clear();
            delete Wunion; delete W;
            Wunion = un;

            SAVEDEBUG(Wunion,"union");

            #if SELFCROSSCONTROL & 4
               if( Wunion->selfcrosscontrol(ShouldTerminate) )
                  Throw("Найдено самопересечение контура после объединения");
            #endif
         }

      }  // конец цикла по всем u из P

      // строим пересечение всех объединений
      if( !Wprev ) { // берем первый элемент
         Wprev = Wunion;
      } else { // и пересекаем его со всеми остальными
         TList<TWinPoly*> ints = Wprev->intersect(Wunion, ShouldTerminate);
         TField *in = new TField(ints);
         ints.clear();
         delete Wprev; delete Wunion;
         Wprev = in;

         SAVEDEBUG(Wprev,"intersection");

         #if SELFCROSSCONTROL & 8
            if( Wprev->selfcrosscontrol(ShouldTerminate) )
               Throw("Найдено самопересечение контура после пересечения");
         #endif
      }

   } // конец цикла по всем v из Q

   // если задача - к моменту времени T, а не в фиксированный момент,
   // то объединяем результат с M
   if( !brdata.fixedT ) {
      TList<TWinPoly*> uns = Wprev->unite(brdata.M, ShouldTerminate);
      TField *res = new TField( uns );
      uns.clear();
      delete Wprev;
      Wprev = res;

      SAVEDEBUG(Wprev,"M-union");
   }

   // если мы ищем выживающие траектории, то пересекаем результат
   // с отсекающим множеством
   if( brdata.survive ) {
      TField far *fsect = brdata.sect(t); // отсекающее множество
      TList<TWinPoly*> uns = Wprev->intersect(fsect, ShouldTerminate);
      TField *res = new TField( uns );
      uns.clear();
      delete Wprev;
      Wprev = res;

      SAVEDEBUG(Wprev,"survive-intersection");
   }

   #if SELFCROSSCONTROL & 16
   if( Wprev->selfcrosscontrol(ShouldTerminate) )
      Throw("Найдено самопересечение результирующего контура");
   #endif

   SAVEDEBUG(Wprev,"result");

   // возвращаем результат
   return Wprev;

}

// "просеять" текущее поле, выкинув из него "лишние" вершины
// функция возвращает количество оставшихся на поле вершин
unsigned long TField::sift(bool volatile *ShouldTerminate) {
   unsigned long vc = 0;   // суммарное кол-во вешин

   #if SELFCROSSCONTROL & 32
   if( selfcrosscontrol(ShouldTerminate) )
      Throw("Найдено самопересечение контура перед просеиванием");
   #endif

   // просто запускаем просеивание для всех многоугольников
   for( long i=0; i<=poly.last(); i++ ) {
      unsigned long vcc = poly[i]->sift(TBrData::sieve, ShouldTerminate);
      if( vcc >= 3 )
         vc += vcc;
      else
         poly.remove(i--);   // выбрасываем двух и одно-угольники :)
      if( ShouldTerminate && *ShouldTerminate )
         return 0;
   }

   #if SELFCROSSCONTROL & 64
   if( selfcrosscontrol(ShouldTerminate) )
      Throw("Найдено самопересечение контура после просеивания");
   #endif

   return vc;
}

// проверить многоугольники на наличие "самопересечений"
// вернуть истину, если "их есть".
bool TField::selfcrosscontrol(bool volatile *ShouldTerminate) {
   // просто запускаем проверку для всех многоугольников
   for( long i=0; i<=poly.last(); i++ ) {
      if( poly[i]->selfcrosscontrol(ShouldTerminate) )
         return true;
      if( ShouldTerminate && *ShouldTerminate )
         break;
   }
   return false;
}

// проверить многоугольники на наличие "самопересечений"
// и избавиться от них
void TField::checkselfcross(bool volatile *ShouldTerminate) {
   // просто запускаем проверку для всех многоугольников
   for( long i=0; i<=poly.last(); i++ ) {
      poly[i]->checkselfcross(ShouldTerminate);
      if( ShouldTerminate && *ShouldTerminate )
         return;
   }

#if CHECKPOLYCROSS==1
   for( long i=0; i<poly.last(); i++ ) {
      for( long j=i+1; j<=poly.last(); j++ ) {
         TList<TWinPoly*> u2 = poly[i]->unite(poly[j], ShouldTerminate);
         if( u2.empty() )
            Throw("Результат объединения двух непустых многоугольников пуст!");
         else if( u2.head() == u2.tail() ) {
            // получили один многоугольник! надо заменить пару i,j на него
            poly.remove(j);
            TWinPoly *oi = poly[i];
            poly[i] = u2.pop();
            delete oi;
            i=0; j=0; // начинаем проверки сначала!
         }
      }
   }
#endif

}

// начать рисовать картинку указанного размера для данного DC
void TField::preparePicture(TDC &DC, TRect region, TWindow *invalidate,
   TDrawThread::TDrawType drtype,
   long double xmin, long double ymin, long double xmax, long double ymax) {
	if( drawThread /*&& drawThread->GetStatus() == TThread::Running */) {
   	drawThread->TerminateAndWait();
      delete drawThread;
      drawThread = NULL;
   }
   if( mDC ) delete mDC;
   mDC = new TMemoryDC(DC);
   clientDC = &DC;
   preparePicture(region,invalidate,drtype,xmin,ymin,xmax,ymax);
}

// начать рисовать картинку указанного размера для ранее определенного DC
void TField::preparePicture(TRect region, TWindow *invalidate,
   TDrawThread::TDrawType drtype,
   long double xmin, long double ymin, long double xmax, long double ymax) {
   if( !mDC )
		Throw("TField::preparePicture: DC not yet defined!");
	if( drawThread ) {
//   	if( drawThread->GetStatus() == TThread::Running )
	   	drawThread->TerminateAndWait();
      delete drawThread;
      drawThread = NULL;
   }
	mDC->RestoreObjects();
	if( mBitmap )
   	delete mBitmap;
   mBitmap = new TBitmap(*clientDC,region.Width(),region.Height());
   mDC->SelectObject(*mBitmap);
   // теперь запускаем рисующий thread
   drawThread = new TDrawThread(mDC,region,this,invalidate,
      drtype,xmin,ymin,xmax,ymax);
   drawThread->Start();
}

// начать рисовать картинку указанного размера
// непосредственно на заданном DC
void TField::preparePictureOnDC(TDC &DC, TRect region,
   TWindow *invalidate, TDrawThread::TDrawType drtype,
   long double xmin, long double ymin, long double xmax, long double ymax) {
	if( drawThread ) {
//   	if( drawThread->GetStatus() == TThread::Running )
	   	drawThread->TerminateAndWait();
      delete drawThread;
      drawThread = NULL;
   }
   if( mDC ) delete mDC;
   mDC = NULL;
	if( mBitmap )
   	delete mBitmap;
   mBitmap = NULL;
   // теперь запускаем рисующий thread
   drawThread = new TDrawThread(&DC,region,this,invalidate,
      drtype,xmin,ymin,xmax,ymax);
   drawThread->Start();
}

// вернуть уже нарисованную картинку (memory DC) или NULL
TDC* TField::getPictureDC() {
	return PictureReady()? mDC : NULL;
}

// вернуть уже нарисованную картинку (bitmap) или NULL
TBitmap* TField::getPictureBitmap() {
	return PictureReady()? mBitmap : NULL;
}

// готова ли картинка?
bool TField::PictureReady() {
	return( drawThread && drawThread->GetStatus() == TThread::Finished );
}

// ждем пока картинка нарисуется
void TField::PictureWaitReady() {
	if( drawThread && drawThread->GetStatus() == TThread::Running )
   	drawThread->WaitForExit();
}

#endif // __DLL__
