//
// Для компиляции и сборки dll используется команда:
// bcc32 -tWDE -eresult.dll file.cpp
//

/*************************************************************
  Задача Эволюционный отбор (выживающие траектории)
  / x' = y
  \ y' = -0.15*y*v - 10.15*sin(x)+u

  u от -10 до 10  => P отрезок от (-10,-10) до (10,10)
  v от 0 до 1     => Q отрезок от (0,0) до (1,1)

  Начальное множество - окружность с центром (0,0) радиуса 1/5
  Отсекающее множество - ???

  Время на отрезке [0;2.25]

*************************************************************/

#include "tfield.h"
#include "dllfunc.h"
#include <math.h>

// версия задачи
#ifndef PROBLEM_CASE
  #define PROBLEM_CASE 2
#endif

// параметры задачи...
#define GOAL_T    2.25  // целевое время
#define T_FIXED   false // к моменту времени
#define DELTA     0.01  // шаг по времени
#define SIEVE     0.005  // ячейка сита

// расширение ограничивающего множества во времени?
#ifndef T_WIDEN
   #if PROBLEM_CASE ==1
      #define T_WIDEN 2
   #elif PROBLEM_CASE == 2
      #define T_WIDEN 0
   #endif
#endif

// Количество вершин, задающих множество P.
// Чем больше, тем точнее расчеты, но и тем дольше будет счет
#ifndef P_POINTS
   #define P_POINTS  11
#else
   #if P_POINTS < 2
      #error "P_POINTS must be 2 or more"
   #endif
#endif

// Количество вершин, задающих множество Q
// Чем больше, тем точнее расчеты, но и тем дольше будет счет
#ifndef Q_POINTS
   #define Q_POINTS  2
#else
   #if Q_POINTS < 2
      #error "Q_POINTS must be 2 or more"
   #endif
#endif

// Количество вершин, задающих множество M
// Чем больше, тем точнее расчеты, но тем больше будет счет
// (хотя и не настолько явно, как в случае P и Q)
#ifndef M_POINTS
   #define M_POINTS  16
#else
   #if M_POINTS < 8
      #error "M_POINTS must be 8 or more"
   #endif
#endif

// Радиус целевого множества M
#ifndef M_RADIUS
   #define M_RADIUS  (1.0/20)
#else
   #if M_RADIUS <= 0
      #error "M_RADIUS must be positive"
   #endif
#endif

// множество P. Задается координатами вершин (последовательно x и y)
ldb P[P_POINTS*2];

// множество Q. Задается координатами вершин (последовательно x и y)
ldb Q[Q_POINTS*2];

// ------------------------------------------------------------
// Функция calcprev - задает попятное движение для точки x при
// заданных векторах управления u,v в момент времени t, шаг по
// времени h
// Параметры (все - long double,
// rx и ry - фактические, остальные формальные):
//    Результирующая точка: (rx,ry)
//    Текущая точка (x):  (cx,cy)
//    Значение управления u: (ux,uy)
//    Значение управления v: (vx,vy)
//    Текущее время t: t
//    Шаг по времени (delta): h
// Результатом работы функции должно быть присвоение значений
// параметрам rx и ry
// ------------------------------------------------------------
#pragma argsused
extern "C" Fcalcprev calcprev {
   // метод Эйлера (попятное движение)
   rx = cx - h*cy;
   ry = cy + h*( 0.15*cy*vy + 10.15*sinl(cy) - uy );
}

// ------------------------------------------------------------
// Функция comment возвращает краткий комментарий, описывающий
// текущую задачу
// ------------------------------------------------------------
extern "C" Fcomment comment {
   #if TWIDEN > 0
      return "Маятник (выживающие траектории) - "
         "ограничение в виде расширяющегося во времени квадратного конуса";
   #else
      return "Маятник (выживающие траектории)";
   #endif
}

// ------------------------------------------------------------
// Функции Pset и Qset задают множества P и Q в виде набора
// координат вершин. Обе этих функции устанавливают значение
// своего первого аргумента в количество вершин. Значение второго
// аргумента устанавливается в указатель на массив координат
// вершин (для каждой вершины в массиве последовательно указывается
// координата x и y)
// ------------------------------------------------------------
extern "C" FPQset Pset {
   // равномерно распределяем P_POINTS точек по отрезку
   // множества P [ от (-10,-10) до (10,10) ]
   ldb step = 20.0/(P_POINTS-1);
   P[0] = P[1] = -10;
   for( int i=2; i<P_POINTS*2; i+=2 )
      P[i] = P[i+1] = P[i-2]+step;

   // возвращаем полученный результат
   pptr = (ldb*)&P;
   pcount = P_POINTS;
}
extern "C" FPQset Qset {
   // равномерно распределяем Q_POINTS точек по отрезку
   // множества P [ от (0,0) до (1,1) ]
   ldb step = 1.0/(Q_POINTS-1);
   Q[0] = Q[1] = 0;
   for( int i=2; i<Q_POINTS*2; i+=2 )
      Q[i] = Q[i+1] = Q[i-2]+step;

   // возвращаем полученный результат
   pptr = (ldb*)&Q;
   pcount = Q_POINTS;
}

// ------------------------------------------------------------
// Функция MField возвращает целевое множество M для текущей
// задачи
// ------------------------------------------------------------
extern "C" FMField MField {
   static TField M;
   static bool init = true;
   if( init ) {
      // равномерно распределяем M_POINTS точек по окружности радиуса M_RADIUS
      ldb rstep = M_PI*2/M_POINTS;
      ldb ang = 0;
      TWinPoly *wp = new TWinPoly();
      for( int i=0; i<M_POINTS; i++ ) {
         ldb x = cosl( ang )*M_RADIUS;
         ldb y = sinl( ang )*M_RADIUS;
         *wp += CPoint( x, y );
         ang += rstep;
      }
      M += wp;
      init = false;
   }
   return &M;
}

// ------------------------------------------------------------
// Функция SecField возвращает отсекающее множество для
// указанного момента времени (сечение отсекающего множества
// в момент времени t)
// ------------------------------------------------------------
#pragma argsused
extern "C" FSecField SecField {
   static TField M;
   #if PROBLEM_CASE == 1
      #if T_WIDEN > 0
         M.clearAll();
         TWinPoly *wp = new TWinPoly();
         ldb coef = 1 + (GOAL_T - t)*(T_WIDEN);
         *wp += CPoint(1*coef,1*coef);
         *wp += CPoint(-1*coef,1*coef);
         *wp += CPoint(-1*coef,-1*coef);
         *wp += CPoint(1*coef,-1*coef);
         M += wp;
      #else
         static bool init = true;
         if( init ) {
            // в любой момент времени - просто квадрат со стороной 2 с центром (0,0)
            TWinPoly *wp = new TWinPoly();
            *wp += CPoint(1,1);
            *wp += CPoint(-1,1);
            *wp += CPoint(-1,-1);
            *wp += CPoint(1,-1);
            M += wp;
            init = false;
         }
      #endif
   #elif PROBLEM_CASE == 2
      static bool init = true;
      if( init ) {
         // в любой момент времени - просто квадрат, повернутый на 45 градусов
         TWinPoly *wp = new TWinPoly();
         *wp += CPoint(-5,5);
         *wp += CPoint(-5,-1);
         *wp += CPoint(1,-1);
         *wp += CPoint(1,5);
         M += wp;
         init = false;
      }
   #endif
   return &M;
}

// ------------------------------------------------------------
// Функция findPvalue - вычисление управления U, путем решения
// относительно него уравнения задачи при известных остальных величинах
// ВНИМАНИЕ!  Движение производится в ПРЯМОМ времени!
// Параметры (все - long double,
// ux и uy - фактические, остальные формальные):
//    Результирующая точка: (rx,ry)
//    Текущая точка (x):  (cx,cy)
//    Искомое значение управления u: (ux,uy)
//    Значение управления v: (vx,vy)
//    Текущее время t: t
//    Шаг по времени (delta): h
// Результатом работы функции должно быть присвоение значений
// параметрам ux и uy
// ------------------------------------------------------------
#pragma argsused
extern "C" FfindPvalue findpvalue {
   ux = uy = ( ry - cy ) / h + 0.15*cy*vy + 10.15*sinl(cy);
}

// ------------------------------------------------------------
// Функция params возвращает значения параметров расчета по
// умолчанию
// ------------------------------------------------------------
extern "C" Fparams params {
   T = GOAL_T;
   sieve = SIEVE;
   fixedT = T_FIXED;
   delta = DELTA;
}

